/*****************************************************************************
 * File generated by HDevelop for HALCON/C Version 23.11.0.0
 * Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
 * Ensure that the interface encoding is set to locale encoding by calling
 * SetHcInterfaceStringEncodingIsUtf8(FALSE) at the beginning of the program.
 * 
 * Please note that non-ASCII characters in string constants are exported
 * as octal codes in order to guarantee that the strings are correctly
 * created on all systems, independent on any compiler settings.
 * 
 * Source files with different encoding should not be mixed in one project.
 *****************************************************************************/

#include "HalconC.h"
#include "halconc/Hdevthread.h"



/* Chapter: Graphics / Text*/
/* Short Description: Write one or multiple text messages. */
void disp_message (Htuple hv_WindowHandle, Htuple hv_String, Htuple hv_CoordSystem, 
    Htuple hv_Row, Htuple hv_Column, Htuple hv_Color, Htuple hv_Box)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_GenParamName, hv_GenParamValue;

  /* Local copy input parameter variables */
  Htuple   hv_Color_COPY_INP_TMP;
  Htuple   hv_Column_COPY_INP_TMP;
  Htuple   hv_CoordSystem_COPY_INP_TMP;
  Htuple   hv_Row_COPY_INP_TMP;


  /* Initialize control variables */
  create_tuple(&hv_GenParamName,0);
  create_tuple(&hv_GenParamValue,0);
  copy_tuple(hv_Color,&hv_Color_COPY_INP_TMP);
  copy_tuple(hv_Column,&hv_Column_COPY_INP_TMP);
  copy_tuple(hv_CoordSystem,&hv_CoordSystem_COPY_INP_TMP);
  copy_tuple(hv_Row,&hv_Row_COPY_INP_TMP);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure displays text in a graphics window.*/
  /**/
  /*Input parameters:*/
  /*WindowHandle: The WindowHandle of the graphics window, where*/
  /*   the message should be displayed.*/
  /*String: A tuple of strings containing the text messages to be displayed.*/
  /*CoordSystem: If set to 'window', the text position is given*/
  /*   with respect to the window coordinate system.*/
  /*   If set to 'image', image coordinates are used.*/
  /*   (This may be useful in zoomed images.)*/
  /*Row: The row coordinate of the desired text position.*/
  /*   You can pass a single value or a tuple of values.*/
  /*   See the explanation below.*/
  /*   Default: 12.*/
  /*Column: The column coordinate of the desired text position.*/
  /*   You can pass a single value or a tuple of values.*/
  /*   See the explanation below.*/
  /*   Default: 12.*/
  /*Color: defines the color of the text as string.*/
  /*   If set to [] or '' the currently set color is used.*/
  /*   If a tuple of strings is passed, the colors are used cyclically*/
  /*   for every text position defined by Row and Column,*/
  /*   or every new text line in case of |Row| == |Column| == 1.*/
  /*Box: A tuple controlling a possible box surrounding the text.*/
  /*   Its entries:*/
  /*   - Box[0]: Controls the box and its color. Possible values:*/
  /*     -- 'true' (Default): An orange box is displayed.*/
  /*     -- 'false': No box is displayed.*/
  /*     -- color string: A box is displayed in the given color, e.g., 'white', '#FF00CC'.*/
  /*   - Box[1] (Optional): Controls the shadow of the box. Possible values:*/
  /*     -- 'true' (Default): A shadow is displayed in*/
  /*               darker orange if Box[0] is not a color and in 'white' otherwise.*/
  /*     -- 'false': No shadow is displayed.*/
  /*     -- color string: A shadow is displayed in the given color, e.g., 'white', '#FF00CC'.*/
  /**/
  /*It is possible to display multiple text strings in a single call.*/
  /*In this case, some restrictions apply on the*/
  /*parameters String, Row, and Column:*/
  /*They can only have either 1 entry or n entries.*/
  /*Behavior in the different cases:*/
  /*   - Multiple text positions are specified, i.e.,*/
  /*       - |Row| == n, |Column| == n*/
  /*       - |Row| == n, |Column| == 1*/
  /*       - |Row| == 1, |Column| == n*/
  /*     In this case we distinguish:*/
  /*       - |String| == n: Each element of String is displayed*/
  /*                        at the corresponding position.*/
  /*       - |String| == 1: String is displayed n times*/
  /*                        at the corresponding positions.*/
  /*   - Exactly one text position is specified,*/
  /*      i.e., |Row| == |Column| == 1:*/
  /*      Each element of String is display in a new textline.*/
  /**/
  /**/
  /*Convert the parameters for disp_text.*/
  /*========== if (Row == [] or Column == []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_Row_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_Column_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local control variables */
    destroy_tuple(hv_GenParamName);
    destroy_tuple(hv_GenParamValue);
    destroy_tuple(hv_Color_COPY_INP_TMP);
    destroy_tuple(hv_Column_COPY_INP_TMP);
    destroy_tuple(hv_CoordSystem_COPY_INP_TMP);
    destroy_tuple(hv_Row_COPY_INP_TMP);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Row == -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_equal(hv_Row_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Row := 12*/
    reuse_tuple_i(&hv_Row_COPY_INP_TMP,12);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Column == -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_equal(hv_Column_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Column := 12*/
    reuse_tuple_i(&hv_Column_COPY_INP_TMP,12);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Convert the parameter Box to generic parameters.*/
  /*GenParamName := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_GenParamName);
  hv_GenParamName=TTemp[--SP];

  /*GenParamValue := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_GenParamValue);
  hv_GenParamValue=TTemp[--SP];

  /*========== if (|Box| > 0) ==========*/
  T_tuple_length(hv_Box,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (Box[0] == 'false') ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"false");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Display no box*/
      /*GenParamName := [GenParamName,'box']*/
      copy_tuple(hv_GenParamName,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"box");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamName);
      hv_GenParamName=TTemp[--SP];

      /*GenParamValue := [GenParamValue,'false']*/
      copy_tuple(hv_GenParamValue,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"false");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamValue);
      hv_GenParamValue=TTemp[--SP];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Box[0] != 'true') ==========*/

    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"true");
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Set a color other than the default.*/
      /*GenParamName := [GenParamName,'box_color']*/
      copy_tuple(hv_GenParamName,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"box_color");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamName);
      hv_GenParamName=TTemp[--SP];

      /*GenParamValue := [GenParamValue,Box[0]]*/
      copy_tuple(hv_GenParamValue,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamValue);
      hv_GenParamValue=TTemp[--SP];

    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (|Box| > 1) ==========*/
  T_tuple_length(hv_Box,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (Box[1] == 'false') ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"false");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Display no shadow.*/
      /*GenParamName := [GenParamName,'shadow']*/
      copy_tuple(hv_GenParamName,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"shadow");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamName);
      hv_GenParamName=TTemp[--SP];

      /*GenParamValue := [GenParamValue,'false']*/
      copy_tuple(hv_GenParamValue,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"false");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamValue);
      hv_GenParamValue=TTemp[--SP];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Box[1] != 'true') ==========*/

    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"true");
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Set a shadow color other than the default.*/
      /*GenParamName := [GenParamName,'shadow_color']*/
      copy_tuple(hv_GenParamName,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"shadow_color");
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamName);
      hv_GenParamName=TTemp[--SP];

      /*GenParamValue := [GenParamValue,Box[1]]*/
      copy_tuple(hv_GenParamValue,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_select(hv_Box,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_GenParamValue);
      hv_GenParamValue=TTemp[--SP];

    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Restore default CoordSystem behavior.*/
  /*========== if (CoordSystem != 'window') ==========*/
  create_tuple_s(&TTemp[SP++],"window");
  T_tuple_not_equal(hv_CoordSystem_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*CoordSystem := 'image'*/
    reuse_tuple_s(&hv_CoordSystem_COPY_INP_TMP,"image");
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== if (Color == '') ==========*/
  create_tuple_s(&TTemp[SP++],"");
  T_tuple_equal(hv_Color_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*disp_text does not accept an empty string for Color.*/
    /*Color := []*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_Color_COPY_INP_TMP);
    hv_Color_COPY_INP_TMP=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*disp_text (WindowHandle, String, CoordSystem, Row, Column, Color, GenParamName, GenParamValue)*/
  /***/T_disp_text(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP, hv_Row_COPY_INP_TMP, 
      hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_GenParamName);
  destroy_tuple(hv_GenParamValue);
  destroy_tuple(hv_Color_COPY_INP_TMP);
  destroy_tuple(hv_Column_COPY_INP_TMP);
  destroy_tuple(hv_CoordSystem_COPY_INP_TMP);
  destroy_tuple(hv_Row_COPY_INP_TMP);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}
