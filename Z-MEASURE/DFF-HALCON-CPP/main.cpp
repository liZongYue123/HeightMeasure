///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
extern void dev_update_off ();
// Chapter: Graphics / Text
// Short Description: Write one or multiple text messages. 
extern void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: File / Misc
// Short Description: Get all image files under the given path 
extern void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);

// Procedures 
#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_ImageArray, ho_Image, ho_ImageDisp;
  HObject  ho_Depth, ho_Confidence, ho_DepthScaleMax, ho_Sharp;
  HObject  ho_ImageScaled, ho_MultiChannelImage;

  // Local control variables
  HTuple  hv_WindowHandle, hv_Names, hv_Index;

  dev_update_off();
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  if (HDevWindowStack::IsOpen())
    hv_WindowHandle = HDevWindowStack::GetActive();
  set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
  if (HDevWindowStack::IsOpen())
    SetPaint(HDevWindowStack::GetActive(),"default");
  //Read the sequence of images
  disp_message(hv_WindowHandle, "Read a sequence of focus images ...", "image", 20, 
      20, "white", "false");
  list_image_files("F:/3D/DepthFromFocus/DepthFromFocus/Origin", "default", HTuple(), 
      &hv_Names);
  ReadImage(&ho_ImageArray, hv_Names);
  ChannelsToImage(ho_ImageArray, &ho_Image);
  // stop(...); only in hdevelop
  for (hv_Index=20; hv_Index<=107; hv_Index+=1)
  {
    AccessChannel(ho_Image, &ho_ImageDisp, hv_Index);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageDisp, HDevWindowStack::GetActive());
    WaitSeconds(0.1);
  }
  //Compute the depth map and display results
  //dev_display (ImageDisp)
  //disp_message (WindowHandle, 'Compute the depth map', 'image', 20, 20, 'white', 'false')
  DepthFromFocus(ho_Image, &ho_Depth, &ho_Confidence, ((HTuple("bandpass").Append(3)).Append(3)), 
      "next_maximum");
  ScaleImageMax(ho_Depth, &ho_DepthScaleMax);
  SelectGrayvaluesFromChannels(ho_Image, ho_Depth, &ho_Sharp);
  ScaleImage(ho_Sharp, &ho_ImageScaled, 8, 0);
  Compose2(ho_DepthScaleMax, ho_ImageScaled, &ho_MultiChannelImage);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //dev_set_paint (['3d_plot', 'texture'])
  //dev_display (MultiChannelImage)
  //disp_message (WindowHandle, '3D reconstruction of IGBT', 'image', 20, 280, 'white', 'false')
}


#ifndef NO_EXPORT_APP_MAIN


int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }

#if defined(_WIN32)
  // On Windows socket communication is no longer possible after returning
  // from main, so HALCON cannot return floating licenses automatically.
  try
  {
    SetSystem("return_license", "true");
  }
  catch (...)
  {
    // Ignore any errors that might occur when returning the license.
  }
#endif

  return ret;
}

#endif


#endif


